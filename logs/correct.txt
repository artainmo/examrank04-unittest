
****************************************
command:
/bin/ls

****************************************
==========output==========
YOU:
microshell.a
microshell.c

BASH:
microshell.a
microshell.c

****************************************
command:
/bin/ls ppp

****************************************
==========output==========
YOU:
ls: ppp: No such file or directory

BASH:
ls: ppp: No such file or directory

****************************************
command:


****************************************
==========output==========
YOU:

BASH:

****************************************
command:
/bin/cat microshell.c

****************************************
==========output==========
YOU:
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>

void launch_cmd(char ***cmds, int i, char **env, int *fd);


void ft_fatal_error()
{
          write(2, "error: fatal\n", 13);
          exit(EXIT_FAILURE); //Only EXIT_FAILURE is the standard value for returning unsuccessful termination, but 1 is used for the same in many implementations.
 }

int ft_strlen2(char **a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

int ft_strlen(char *a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

void ft_cd(char **cmd)
{
	if (ft_strlen2(cmd) != 2)
		write(2, "error: cd: bad arguments\n", 25);
	else
	{
		if (chdir(cmd[1]) == -1)
		{
			write(2, "error: cd: cannot change directory to ", 38);
			write(2, cmd[1], ft_strlen(cmd[1]));
			write(2, "\n", 1);
		}
	}
}

void ft_exec(char **cmd, char **env)
{
	pid_t pid;

	if ((pid = fork()) == -1)
			ft_fatal_error();
	if (!pid)
	{
		if (execve(cmd[0], cmd, env) == -1)
		{
			write(2, "error: cannot execute ", 22);
			write(2, cmd[0], ft_strlen(cmd[0]));
			write(2, "\n", 1);
		}
		exit(0);
	}
	if (waitpid(pid, 0, 0) == -1)
		ft_fatal_error();
}

void ft_pipe(char ***cmd, int i, char **env, int *fd)
{
  pid_t pid;

	if (pipe(fd) == -1)
		ft_fatal_error();
	if ((pid = fork()) == -1)
		ft_fatal_error();
	if (!pid)
	{
		if (close(fd[0]) == -1)
			ft_fatal_error();
		if (dup2(fd[1], 1) == -1)
			ft_fatal_error();
		ft_exec(cmd[i], env);
		if (dup2(1, fd[1]) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		exit(0);
	}
	else
	{
		if (waitpid(pid, 0, 0) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		if (dup2(fd[0], 0) == -1)
			ft_fatal_error();
		launch_cmd(cmd, i + 2, env, fd);
		if (dup2(0, fd[0]) == -1)
			ft_fatal_error();
	}
}

void launch_cmd(char ***cmds, int i, char **env, int *fd)
{
	//printf("{%s %s}\n", cmds[i][0], cmds[i][1]);
	if (cmds[i + 1] != 0 && strcmp(cmds[i + 1][0], "|") == 0)
  {
    close(fd[0]);
		ft_pipe(cmds, i,  env, fd);
  }
	else if (strcmp(cmds[i][0], "cd") == 0)
		ft_cd(cmds[i]);
	else
		ft_exec(cmds[i], env);
}

void launch_cmds(char ***cmds, char **env)
{
	int i;
  int fd[2];

	i = 0;
	while (cmds[i])
	{
		if (strcmp(cmds[i][0], "|") == 0)
		{
			while(cmds[i] && strcmp(cmds[i][0], "|") == 0)
				i += 2;
			if (!cmds[i])
				break ;
		}
		launch_cmd(cmds, i, env, fd);
		i++;
	}
}

void parsing(int argc, char **argv, char ***cmds)
{
	int i;
	int l;
	int m;

	i = 1;
	l = 0;
	m = 0;
	if ((cmds[0] = malloc(sizeof(char *) * argc + 1)) == 0)
		ft_fatal_error();
	while (i < argc)
	{
		if (i == argc - 1 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			break ;
		else if (m == 0 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			(void)0;
		else if (strcmp(argv[i], ";") == 0)
		{
			cmds[l][m] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else if (strcmp(argv[i], "|") == 0)
		{
			cmds[l][m] = 0;
			l++;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
			cmds[l][0] = argv[i];
			cmds[l][1] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else
		{
			cmds[l][m] = argv[i];
			//printf("|%s|\n", cmds[l][m]);
			m++;
		}
		i++;
	}
	if (m == 0)
		cmds[l] = 0;
	else
	{
		cmds[l][m] = 0;
		cmds[l + 1] = 0;
	}
}

int main(int argc, char **argv, char **env)
{
	char ***cmds; //First split with | and ; //Second with words for each command

	if (argc == 1)
		return (0);
	if ((cmds = malloc(sizeof(char *) * argc + 1)) == 0) //allocate max memory potentially necessary each time
		ft_fatal_error();
	parsing(argc, argv, cmds);
	launch_cmds(cmds, env);
	exit(0); //No leaks
}

BASH:
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>

void launch_cmd(char ***cmds, int i, char **env, int *fd);


void ft_fatal_error()
{
          write(2, "error: fatal\n", 13);
          exit(EXIT_FAILURE); //Only EXIT_FAILURE is the standard value for returning unsuccessful termination, but 1 is used for the same in many implementations.
 }

int ft_strlen2(char **a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

int ft_strlen(char *a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

void ft_cd(char **cmd)
{
	if (ft_strlen2(cmd) != 2)
		write(2, "error: cd: bad arguments\n", 25);
	else
	{
		if (chdir(cmd[1]) == -1)
		{
			write(2, "error: cd: cannot change directory to ", 38);
			write(2, cmd[1], ft_strlen(cmd[1]));
			write(2, "\n", 1);
		}
	}
}

void ft_exec(char **cmd, char **env)
{
	pid_t pid;

	if ((pid = fork()) == -1)
			ft_fatal_error();
	if (!pid)
	{
		if (execve(cmd[0], cmd, env) == -1)
		{
			write(2, "error: cannot execute ", 22);
			write(2, cmd[0], ft_strlen(cmd[0]));
			write(2, "\n", 1);
		}
		exit(0);
	}
	if (waitpid(pid, 0, 0) == -1)
		ft_fatal_error();
}

void ft_pipe(char ***cmd, int i, char **env, int *fd)
{
  pid_t pid;

	if (pipe(fd) == -1)
		ft_fatal_error();
	if ((pid = fork()) == -1)
		ft_fatal_error();
	if (!pid)
	{
		if (close(fd[0]) == -1)
			ft_fatal_error();
		if (dup2(fd[1], 1) == -1)
			ft_fatal_error();
		ft_exec(cmd[i], env);
		if (dup2(1, fd[1]) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		exit(0);
	}
	else
	{
		if (waitpid(pid, 0, 0) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		if (dup2(fd[0], 0) == -1)
			ft_fatal_error();
		launch_cmd(cmd, i + 2, env, fd);
		if (dup2(0, fd[0]) == -1)
			ft_fatal_error();
	}
}

void launch_cmd(char ***cmds, int i, char **env, int *fd)
{
	//printf("{%s %s}\n", cmds[i][0], cmds[i][1]);
	if (cmds[i + 1] != 0 && strcmp(cmds[i + 1][0], "|") == 0)
  {
    close(fd[0]);
		ft_pipe(cmds, i,  env, fd);
  }
	else if (strcmp(cmds[i][0], "cd") == 0)
		ft_cd(cmds[i]);
	else
		ft_exec(cmds[i], env);
}

void launch_cmds(char ***cmds, char **env)
{
	int i;
  int fd[2];

	i = 0;
	while (cmds[i])
	{
		if (strcmp(cmds[i][0], "|") == 0)
		{
			while(cmds[i] && strcmp(cmds[i][0], "|") == 0)
				i += 2;
			if (!cmds[i])
				break ;
		}
		launch_cmd(cmds, i, env, fd);
		i++;
	}
}

void parsing(int argc, char **argv, char ***cmds)
{
	int i;
	int l;
	int m;

	i = 1;
	l = 0;
	m = 0;
	if ((cmds[0] = malloc(sizeof(char *) * argc + 1)) == 0)
		ft_fatal_error();
	while (i < argc)
	{
		if (i == argc - 1 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			break ;
		else if (m == 0 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			(void)0;
		else if (strcmp(argv[i], ";") == 0)
		{
			cmds[l][m] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else if (strcmp(argv[i], "|") == 0)
		{
			cmds[l][m] = 0;
			l++;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
			cmds[l][0] = argv[i];
			cmds[l][1] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else
		{
			cmds[l][m] = argv[i];
			//printf("|%s|\n", cmds[l][m]);
			m++;
		}
		i++;
	}
	if (m == 0)
		cmds[l] = 0;
	else
	{
		cmds[l][m] = 0;
		cmds[l + 1] = 0;
	}
}

int main(int argc, char **argv, char **env)
{
	char ***cmds; //First split with | and ; //Second with words for each command

	if (argc == 1)
		return (0);
	if ((cmds = malloc(sizeof(char *) * argc + 1)) == 0) //allocate max memory potentially necessary each time
		ft_fatal_error();
	parsing(argc, argv, cmds);
	launch_cmds(cmds, env);
	exit(0); //No leaks
}

****************************************
command:
/bin/ls microshell.c

****************************************
==========output==========
YOU:
microshell.c

BASH:
microshell.c

****************************************
command:
/bin/pwd ";" /bin/cat microshell.c ";" /bin/ls "|" /usr/bin/grep microshell "|" /usr/bin/grep l.c ";" /bin/echo i love my microshell ";"

****************************************
==========output==========
YOU:
/Users/arthurtainmont/Documents/programming/examrank04_unittest/microshell
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>

void launch_cmd(char ***cmds, int i, char **env, int *fd);


void ft_fatal_error()
{
          write(2, "error: fatal\n", 13);
          exit(EXIT_FAILURE); //Only EXIT_FAILURE is the standard value for returning unsuccessful termination, but 1 is used for the same in many implementations.
 }

int ft_strlen2(char **a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

int ft_strlen(char *a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

void ft_cd(char **cmd)
{
	if (ft_strlen2(cmd) != 2)
		write(2, "error: cd: bad arguments\n", 25);
	else
	{
		if (chdir(cmd[1]) == -1)
		{
			write(2, "error: cd: cannot change directory to ", 38);
			write(2, cmd[1], ft_strlen(cmd[1]));
			write(2, "\n", 1);
		}
	}
}

void ft_exec(char **cmd, char **env)
{
	pid_t pid;

	if ((pid = fork()) == -1)
			ft_fatal_error();
	if (!pid)
	{
		if (execve(cmd[0], cmd, env) == -1)
		{
			write(2, "error: cannot execute ", 22);
			write(2, cmd[0], ft_strlen(cmd[0]));
			write(2, "\n", 1);
		}
		exit(0);
	}
	if (waitpid(pid, 0, 0) == -1)
		ft_fatal_error();
}

void ft_pipe(char ***cmd, int i, char **env, int *fd)
{
  pid_t pid;

	if (pipe(fd) == -1)
		ft_fatal_error();
	if ((pid = fork()) == -1)
		ft_fatal_error();
	if (!pid)
	{
		if (close(fd[0]) == -1)
			ft_fatal_error();
		if (dup2(fd[1], 1) == -1)
			ft_fatal_error();
		ft_exec(cmd[i], env);
		if (dup2(1, fd[1]) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		exit(0);
	}
	else
	{
		if (waitpid(pid, 0, 0) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		if (dup2(fd[0], 0) == -1)
			ft_fatal_error();
		launch_cmd(cmd, i + 2, env, fd);
		if (dup2(0, fd[0]) == -1)
			ft_fatal_error();
	}
}

void launch_cmd(char ***cmds, int i, char **env, int *fd)
{
	//printf("{%s %s}\n", cmds[i][0], cmds[i][1]);
	if (cmds[i + 1] != 0 && strcmp(cmds[i + 1][0], "|") == 0)
  {
    close(fd[0]);
		ft_pipe(cmds, i,  env, fd);
  }
	else if (strcmp(cmds[i][0], "cd") == 0)
		ft_cd(cmds[i]);
	else
		ft_exec(cmds[i], env);
}

void launch_cmds(char ***cmds, char **env)
{
	int i;
  int fd[2];

	i = 0;
	while (cmds[i])
	{
		if (strcmp(cmds[i][0], "|") == 0)
		{
			while(cmds[i] && strcmp(cmds[i][0], "|") == 0)
				i += 2;
			if (!cmds[i])
				break ;
		}
		launch_cmd(cmds, i, env, fd);
		i++;
	}
}

void parsing(int argc, char **argv, char ***cmds)
{
	int i;
	int l;
	int m;

	i = 1;
	l = 0;
	m = 0;
	if ((cmds[0] = malloc(sizeof(char *) * argc + 1)) == 0)
		ft_fatal_error();
	while (i < argc)
	{
		if (i == argc - 1 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			break ;
		else if (m == 0 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			(void)0;
		else if (strcmp(argv[i], ";") == 0)
		{
			cmds[l][m] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else if (strcmp(argv[i], "|") == 0)
		{
			cmds[l][m] = 0;
			l++;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
			cmds[l][0] = argv[i];
			cmds[l][1] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else
		{
			cmds[l][m] = argv[i];
			//printf("|%s|\n", cmds[l][m]);
			m++;
		}
		i++;
	}
	if (m == 0)
		cmds[l] = 0;
	else
	{
		cmds[l][m] = 0;
		cmds[l + 1] = 0;
	}
}

int main(int argc, char **argv, char **env)
{
	char ***cmds; //First split with | and ; //Second with words for each command

	if (argc == 1)
		return (0);
	if ((cmds = malloc(sizeof(char *) * argc + 1)) == 0) //allocate max memory potentially necessary each time
		ft_fatal_error();
	parsing(argc, argv, cmds);
	launch_cmds(cmds, env);
	exit(0); //No leaks
}
microshell.c
i love my microshell

BASH:
/Users/arthurtainmont/Documents/programming/examrank04_unittest/microshell
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>

void launch_cmd(char ***cmds, int i, char **env, int *fd);


void ft_fatal_error()
{
          write(2, "error: fatal\n", 13);
          exit(EXIT_FAILURE); //Only EXIT_FAILURE is the standard value for returning unsuccessful termination, but 1 is used for the same in many implementations.
 }

int ft_strlen2(char **a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

int ft_strlen(char *a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

void ft_cd(char **cmd)
{
	if (ft_strlen2(cmd) != 2)
		write(2, "error: cd: bad arguments\n", 25);
	else
	{
		if (chdir(cmd[1]) == -1)
		{
			write(2, "error: cd: cannot change directory to ", 38);
			write(2, cmd[1], ft_strlen(cmd[1]));
			write(2, "\n", 1);
		}
	}
}

void ft_exec(char **cmd, char **env)
{
	pid_t pid;

	if ((pid = fork()) == -1)
			ft_fatal_error();
	if (!pid)
	{
		if (execve(cmd[0], cmd, env) == -1)
		{
			write(2, "error: cannot execute ", 22);
			write(2, cmd[0], ft_strlen(cmd[0]));
			write(2, "\n", 1);
		}
		exit(0);
	}
	if (waitpid(pid, 0, 0) == -1)
		ft_fatal_error();
}

void ft_pipe(char ***cmd, int i, char **env, int *fd)
{
  pid_t pid;

	if (pipe(fd) == -1)
		ft_fatal_error();
	if ((pid = fork()) == -1)
		ft_fatal_error();
	if (!pid)
	{
		if (close(fd[0]) == -1)
			ft_fatal_error();
		if (dup2(fd[1], 1) == -1)
			ft_fatal_error();
		ft_exec(cmd[i], env);
		if (dup2(1, fd[1]) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		exit(0);
	}
	else
	{
		if (waitpid(pid, 0, 0) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		if (dup2(fd[0], 0) == -1)
			ft_fatal_error();
		launch_cmd(cmd, i + 2, env, fd);
		if (dup2(0, fd[0]) == -1)
			ft_fatal_error();
	}
}

void launch_cmd(char ***cmds, int i, char **env, int *fd)
{
	//printf("{%s %s}\n", cmds[i][0], cmds[i][1]);
	if (cmds[i + 1] != 0 && strcmp(cmds[i + 1][0], "|") == 0)
  {
    close(fd[0]);
		ft_pipe(cmds, i,  env, fd);
  }
	else if (strcmp(cmds[i][0], "cd") == 0)
		ft_cd(cmds[i]);
	else
		ft_exec(cmds[i], env);
}

void launch_cmds(char ***cmds, char **env)
{
	int i;
  int fd[2];

	i = 0;
	while (cmds[i])
	{
		if (strcmp(cmds[i][0], "|") == 0)
		{
			while(cmds[i] && strcmp(cmds[i][0], "|") == 0)
				i += 2;
			if (!cmds[i])
				break ;
		}
		launch_cmd(cmds, i, env, fd);
		i++;
	}
}

void parsing(int argc, char **argv, char ***cmds)
{
	int i;
	int l;
	int m;

	i = 1;
	l = 0;
	m = 0;
	if ((cmds[0] = malloc(sizeof(char *) * argc + 1)) == 0)
		ft_fatal_error();
	while (i < argc)
	{
		if (i == argc - 1 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			break ;
		else if (m == 0 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			(void)0;
		else if (strcmp(argv[i], ";") == 0)
		{
			cmds[l][m] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else if (strcmp(argv[i], "|") == 0)
		{
			cmds[l][m] = 0;
			l++;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
			cmds[l][0] = argv[i];
			cmds[l][1] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else
		{
			cmds[l][m] = argv[i];
			//printf("|%s|\n", cmds[l][m]);
			m++;
		}
		i++;
	}
	if (m == 0)
		cmds[l] = 0;
	else
	{
		cmds[l][m] = 0;
		cmds[l + 1] = 0;
	}
}

int main(int argc, char **argv, char **env)
{
	char ***cmds; //First split with | and ; //Second with words for each command

	if (argc == 1)
		return (0);
	if ((cmds = malloc(sizeof(char *) * argc + 1)) == 0) //allocate max memory potentially necessary each time
		ft_fatal_error();
	parsing(argc, argv, cmds);
	launch_cmds(cmds, env);
	exit(0); //No leaks
}
microshell.c
i love my microshell

****************************************
command:
/bin/ls "|" /usr/bin/grep microshell "|" /usr/bin/grep l.c ";" /bin/echo pppp ";" /bin/echo d

****************************************
==========output==========
YOU:
microshell.c
pppp
d

BASH:
microshell.c
pppp
d

****************************************
command:
/bin/ls "|" /usr/bin/grep microshell "|" /usr/bin/grep l.c ";" /bin/echo i love my microshell

****************************************
==========output==========
YOU:
microshell.c
i love my microshell

BASH:
microshell.c
i love my microshell

****************************************
command:
/bin/cat microshell.c ";" /bin/ls "|" /usr/bin/grep microshell ";" /bin/echo i love my microshell

****************************************
==========output==========
YOU:
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>

void launch_cmd(char ***cmds, int i, char **env, int *fd);


void ft_fatal_error()
{
          write(2, "error: fatal\n", 13);
          exit(EXIT_FAILURE); //Only EXIT_FAILURE is the standard value for returning unsuccessful termination, but 1 is used for the same in many implementations.
 }

int ft_strlen2(char **a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

int ft_strlen(char *a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

void ft_cd(char **cmd)
{
	if (ft_strlen2(cmd) != 2)
		write(2, "error: cd: bad arguments\n", 25);
	else
	{
		if (chdir(cmd[1]) == -1)
		{
			write(2, "error: cd: cannot change directory to ", 38);
			write(2, cmd[1], ft_strlen(cmd[1]));
			write(2, "\n", 1);
		}
	}
}

void ft_exec(char **cmd, char **env)
{
	pid_t pid;

	if ((pid = fork()) == -1)
			ft_fatal_error();
	if (!pid)
	{
		if (execve(cmd[0], cmd, env) == -1)
		{
			write(2, "error: cannot execute ", 22);
			write(2, cmd[0], ft_strlen(cmd[0]));
			write(2, "\n", 1);
		}
		exit(0);
	}
	if (waitpid(pid, 0, 0) == -1)
		ft_fatal_error();
}

void ft_pipe(char ***cmd, int i, char **env, int *fd)
{
  pid_t pid;

	if (pipe(fd) == -1)
		ft_fatal_error();
	if ((pid = fork()) == -1)
		ft_fatal_error();
	if (!pid)
	{
		if (close(fd[0]) == -1)
			ft_fatal_error();
		if (dup2(fd[1], 1) == -1)
			ft_fatal_error();
		ft_exec(cmd[i], env);
		if (dup2(1, fd[1]) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		exit(0);
	}
	else
	{
		if (waitpid(pid, 0, 0) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		if (dup2(fd[0], 0) == -1)
			ft_fatal_error();
		launch_cmd(cmd, i + 2, env, fd);
		if (dup2(0, fd[0]) == -1)
			ft_fatal_error();
	}
}

void launch_cmd(char ***cmds, int i, char **env, int *fd)
{
	//printf("{%s %s}\n", cmds[i][0], cmds[i][1]);
	if (cmds[i + 1] != 0 && strcmp(cmds[i + 1][0], "|") == 0)
  {
    close(fd[0]);
		ft_pipe(cmds, i,  env, fd);
  }
	else if (strcmp(cmds[i][0], "cd") == 0)
		ft_cd(cmds[i]);
	else
		ft_exec(cmds[i], env);
}

void launch_cmds(char ***cmds, char **env)
{
	int i;
  int fd[2];

	i = 0;
	while (cmds[i])
	{
		if (strcmp(cmds[i][0], "|") == 0)
		{
			while(cmds[i] && strcmp(cmds[i][0], "|") == 0)
				i += 2;
			if (!cmds[i])
				break ;
		}
		launch_cmd(cmds, i, env, fd);
		i++;
	}
}

void parsing(int argc, char **argv, char ***cmds)
{
	int i;
	int l;
	int m;

	i = 1;
	l = 0;
	m = 0;
	if ((cmds[0] = malloc(sizeof(char *) * argc + 1)) == 0)
		ft_fatal_error();
	while (i < argc)
	{
		if (i == argc - 1 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			break ;
		else if (m == 0 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			(void)0;
		else if (strcmp(argv[i], ";") == 0)
		{
			cmds[l][m] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else if (strcmp(argv[i], "|") == 0)
		{
			cmds[l][m] = 0;
			l++;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
			cmds[l][0] = argv[i];
			cmds[l][1] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else
		{
			cmds[l][m] = argv[i];
			//printf("|%s|\n", cmds[l][m]);
			m++;
		}
		i++;
	}
	if (m == 0)
		cmds[l] = 0;
	else
	{
		cmds[l][m] = 0;
		cmds[l + 1] = 0;
	}
}

int main(int argc, char **argv, char **env)
{
	char ***cmds; //First split with | and ; //Second with words for each command

	if (argc == 1)
		return (0);
	if ((cmds = malloc(sizeof(char *) * argc + 1)) == 0) //allocate max memory potentially necessary each time
		ft_fatal_error();
	parsing(argc, argv, cmds);
	launch_cmds(cmds, env);
	exit(0); //No leaks
}
microshell.a
microshell.c
i love my microshell

BASH:
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>

void launch_cmd(char ***cmds, int i, char **env, int *fd);


void ft_fatal_error()
{
          write(2, "error: fatal\n", 13);
          exit(EXIT_FAILURE); //Only EXIT_FAILURE is the standard value for returning unsuccessful termination, but 1 is used for the same in many implementations.
 }

int ft_strlen2(char **a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

int ft_strlen(char *a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

void ft_cd(char **cmd)
{
	if (ft_strlen2(cmd) != 2)
		write(2, "error: cd: bad arguments\n", 25);
	else
	{
		if (chdir(cmd[1]) == -1)
		{
			write(2, "error: cd: cannot change directory to ", 38);
			write(2, cmd[1], ft_strlen(cmd[1]));
			write(2, "\n", 1);
		}
	}
}

void ft_exec(char **cmd, char **env)
{
	pid_t pid;

	if ((pid = fork()) == -1)
			ft_fatal_error();
	if (!pid)
	{
		if (execve(cmd[0], cmd, env) == -1)
		{
			write(2, "error: cannot execute ", 22);
			write(2, cmd[0], ft_strlen(cmd[0]));
			write(2, "\n", 1);
		}
		exit(0);
	}
	if (waitpid(pid, 0, 0) == -1)
		ft_fatal_error();
}

void ft_pipe(char ***cmd, int i, char **env, int *fd)
{
  pid_t pid;

	if (pipe(fd) == -1)
		ft_fatal_error();
	if ((pid = fork()) == -1)
		ft_fatal_error();
	if (!pid)
	{
		if (close(fd[0]) == -1)
			ft_fatal_error();
		if (dup2(fd[1], 1) == -1)
			ft_fatal_error();
		ft_exec(cmd[i], env);
		if (dup2(1, fd[1]) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		exit(0);
	}
	else
	{
		if (waitpid(pid, 0, 0) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		if (dup2(fd[0], 0) == -1)
			ft_fatal_error();
		launch_cmd(cmd, i + 2, env, fd);
		if (dup2(0, fd[0]) == -1)
			ft_fatal_error();
	}
}

void launch_cmd(char ***cmds, int i, char **env, int *fd)
{
	//printf("{%s %s}\n", cmds[i][0], cmds[i][1]);
	if (cmds[i + 1] != 0 && strcmp(cmds[i + 1][0], "|") == 0)
  {
    close(fd[0]);
		ft_pipe(cmds, i,  env, fd);
  }
	else if (strcmp(cmds[i][0], "cd") == 0)
		ft_cd(cmds[i]);
	else
		ft_exec(cmds[i], env);
}

void launch_cmds(char ***cmds, char **env)
{
	int i;
  int fd[2];

	i = 0;
	while (cmds[i])
	{
		if (strcmp(cmds[i][0], "|") == 0)
		{
			while(cmds[i] && strcmp(cmds[i][0], "|") == 0)
				i += 2;
			if (!cmds[i])
				break ;
		}
		launch_cmd(cmds, i, env, fd);
		i++;
	}
}

void parsing(int argc, char **argv, char ***cmds)
{
	int i;
	int l;
	int m;

	i = 1;
	l = 0;
	m = 0;
	if ((cmds[0] = malloc(sizeof(char *) * argc + 1)) == 0)
		ft_fatal_error();
	while (i < argc)
	{
		if (i == argc - 1 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			break ;
		else if (m == 0 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			(void)0;
		else if (strcmp(argv[i], ";") == 0)
		{
			cmds[l][m] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else if (strcmp(argv[i], "|") == 0)
		{
			cmds[l][m] = 0;
			l++;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
			cmds[l][0] = argv[i];
			cmds[l][1] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else
		{
			cmds[l][m] = argv[i];
			//printf("|%s|\n", cmds[l][m]);
			m++;
		}
		i++;
	}
	if (m == 0)
		cmds[l] = 0;
	else
	{
		cmds[l][m] = 0;
		cmds[l + 1] = 0;
	}
}

int main(int argc, char **argv, char **env)
{
	char ***cmds; //First split with | and ; //Second with words for each command

	if (argc == 1)
		return (0);
	if ((cmds = malloc(sizeof(char *) * argc + 1)) == 0) //allocate max memory potentially necessary each time
		ft_fatal_error();
	parsing(argc, argv, cmds);
	launch_cmds(cmds, env);
	exit(0); //No leaks
}
microshell.a
microshell.c
i love my microshell

****************************************
command:
/bin/ls ";" /bin/echo i love my microshell

****************************************
==========output==========
YOU:
microshell.a
microshell.c
i love my microshell

BASH:
microshell.a
microshell.c
i love my microshell

****************************************
command:
/bin/ls "|" /usr/bin/grep microshell

****************************************
==========output==========
YOU:
microshell.a
microshell.c

BASH:
microshell.a
microshell.c

****************************************
command:
/bin/ls "|" /usr/bin/grep microshell "|" /usr/bin/grep micro

****************************************
==========output==========
YOU:
microshell.a
microshell.c

BASH:
microshell.a
microshell.c

****************************************
command:
/bin/ls "|" /usr/bin/grep microshell "|" /usr/bin/grep micro "|" /usr/bin/grep shell "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro

****************************************
==========output==========
YOU:
microshell.a
microshell.c

BASH:
microshell.a
microshell.c

****************************************
command:
/bin/ls "|" /usr/bin/grep microshell "|" /usr/bin/grep micro "|" /usr/bin/grep shell "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep micro "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell "|" /usr/bin/grep shell

****************************************
==========output==========
YOU:
microshell.a
microshell.c

BASH:
microshell.a
microshell.c

****************************************
command:
/bin/ls ewqew "|" /usr/bin/grep micro "|" /bin/cat -n ";" /bin/echo dernier ";" /bin/echo

****************************************
==========output==========
YOU:
ls: ewqew: No such file or directory
dernier


BASH:
ls: ewqew: No such file or directory
dernier


****************************************
command:
/bin/ls "|" /usr/bin/grep micro "|" /bin/cat -n ";" /bin/echo dernier ";" /bin/echo ftest ";"

****************************************
==========output==========
YOU:
     1	microshell.a
     2	microshell.c
dernier
ftest

BASH:
     1	microshell.a
     2	microshell.c
dernier
ftest

****************************************
command:
/bin/echo ftest ";" /bin/echo ftewerwerwerst ";" /bin/echo werwerwer ";" /bin/echo qweqweqweqew ";" /bin/echo qwewqeqrtregrfyukui ";"

****************************************
==========output==========
YOU:
ftest
ftewerwerwerst
werwerwer
qweqweqweqew
qwewqeqrtregrfyukui

BASH:
ftest
ftewerwerwerst
werwerwer
qweqweqweqew
qwewqeqrtregrfyukui

****************************************
command:
/bin/ls ftest ";" /bin/ls ";" /bin/ls werwer ";" /bin/ls microshell.c ";" /bin/ls microshell.c ";"

****************************************
==========output==========
YOU:
ls: ftest: No such file or directory
ls: werwer: No such file or directory
microshell.a
microshell.c
microshell.c
microshell.c

BASH:
ls: ftest: No such file or directory
ls: werwer: No such file or directory
microshell.a
microshell.c
microshell.c
microshell.c

****************************************
command:
/bin/ls "|" /usr/bin/grep micro ";" /bin/ls "|" /usr/bin/grep micro ";" /bin/ls "|" /usr/bin/grep micro ";" /bin/ls "|" /usr/bin/grep micro ";"

****************************************
==========output==========
YOU:
microshell.a
microshell.c
microshell.a
microshell.c
microshell.a
microshell.c
microshell.a
microshell.c

BASH:
microshell.a
microshell.c
microshell.a
microshell.c
microshell.a
microshell.c
microshell.a
microshell.c

****************************************
command:
/bin/cat microshell.c "|" /usr/bin/grep a "|" /usr/bin/grep l ";" /bin/cat microshell.c ";"

****************************************
==========output==========
YOU:
#include <sys/wait.h>
void launch_cmd(char ***cmds, int i, char **env, int *fd);
void ft_fatal_error()
          write(2, "error: fatal\n", 13);
          exit(EXIT_FAILURE); //Only EXIT_FAILURE is the standard value for returning unsuccessful termination, but 1 is used for the same in many implementations.
int ft_strlen2(char **a)
	while(a[i])
int ft_strlen(char *a)
	while(a[i])
			ft_fatal_error();
		ft_fatal_error();
		ft_fatal_error();
		ft_fatal_error();
			ft_fatal_error();
			ft_fatal_error();
			ft_fatal_error();
			ft_fatal_error();
			ft_fatal_error();
			ft_fatal_error();
			ft_fatal_error();
		launch_cmd(cmd, i + 2, env, fd);
			ft_fatal_error();
void launch_cmd(char ***cmds, int i, char **env, int *fd)
void launch_cmds(char ***cmds, char **env)
		launch_cmd(cmds, i, env, fd);
	if ((cmds[0] = malloc(sizeof(char *) * argc + 1)) == 0)
		ft_fatal_error();
	while (i < argc)
		else if (m == 0 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
		else if (strcmp(argv[i], ";") == 0)
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		else if (strcmp(argv[i], "|") == 0)
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
			cmds[l][0] = argv[i];
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
			cmds[l][m] = argv[i];
	char ***cmds; //First split with | and ; //Second with words for each command
	if ((cmds = malloc(sizeof(char *) * argc + 1)) == 0) //allocate max memory potentially necessary each time
		ft_fatal_error();
	launch_cmds(cmds, env);
	exit(0); //No leaks
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>

void launch_cmd(char ***cmds, int i, char **env, int *fd);


void ft_fatal_error()
{
          write(2, "error: fatal\n", 13);
          exit(EXIT_FAILURE); //Only EXIT_FAILURE is the standard value for returning unsuccessful termination, but 1 is used for the same in many implementations.
 }

int ft_strlen2(char **a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

int ft_strlen(char *a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

void ft_cd(char **cmd)
{
	if (ft_strlen2(cmd) != 2)
		write(2, "error: cd: bad arguments\n", 25);
	else
	{
		if (chdir(cmd[1]) == -1)
		{
			write(2, "error: cd: cannot change directory to ", 38);
			write(2, cmd[1], ft_strlen(cmd[1]));
			write(2, "\n", 1);
		}
	}
}

void ft_exec(char **cmd, char **env)
{
	pid_t pid;

	if ((pid = fork()) == -1)
			ft_fatal_error();
	if (!pid)
	{
		if (execve(cmd[0], cmd, env) == -1)
		{
			write(2, "error: cannot execute ", 22);
			write(2, cmd[0], ft_strlen(cmd[0]));
			write(2, "\n", 1);
		}
		exit(0);
	}
	if (waitpid(pid, 0, 0) == -1)
		ft_fatal_error();
}

void ft_pipe(char ***cmd, int i, char **env, int *fd)
{
  pid_t pid;

	if (pipe(fd) == -1)
		ft_fatal_error();
	if ((pid = fork()) == -1)
		ft_fatal_error();
	if (!pid)
	{
		if (close(fd[0]) == -1)
			ft_fatal_error();
		if (dup2(fd[1], 1) == -1)
			ft_fatal_error();
		ft_exec(cmd[i], env);
		if (dup2(1, fd[1]) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		exit(0);
	}
	else
	{
		if (waitpid(pid, 0, 0) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		if (dup2(fd[0], 0) == -1)
			ft_fatal_error();
		launch_cmd(cmd, i + 2, env, fd);
		if (dup2(0, fd[0]) == -1)
			ft_fatal_error();
	}
}

void launch_cmd(char ***cmds, int i, char **env, int *fd)
{
	//printf("{%s %s}\n", cmds[i][0], cmds[i][1]);
	if (cmds[i + 1] != 0 && strcmp(cmds[i + 1][0], "|") == 0)
  {
    close(fd[0]);
		ft_pipe(cmds, i,  env, fd);
  }
	else if (strcmp(cmds[i][0], "cd") == 0)
		ft_cd(cmds[i]);
	else
		ft_exec(cmds[i], env);
}

void launch_cmds(char ***cmds, char **env)
{
	int i;
  int fd[2];

	i = 0;
	while (cmds[i])
	{
		if (strcmp(cmds[i][0], "|") == 0)
		{
			while(cmds[i] && strcmp(cmds[i][0], "|") == 0)
				i += 2;
			if (!cmds[i])
				break ;
		}
		launch_cmd(cmds, i, env, fd);
		i++;
	}
}

void parsing(int argc, char **argv, char ***cmds)
{
	int i;
	int l;
	int m;

	i = 1;
	l = 0;
	m = 0;
	if ((cmds[0] = malloc(sizeof(char *) * argc + 1)) == 0)
		ft_fatal_error();
	while (i < argc)
	{
		if (i == argc - 1 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			break ;
		else if (m == 0 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			(void)0;
		else if (strcmp(argv[i], ";") == 0)
		{
			cmds[l][m] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else if (strcmp(argv[i], "|") == 0)
		{
			cmds[l][m] = 0;
			l++;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
			cmds[l][0] = argv[i];
			cmds[l][1] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else
		{
			cmds[l][m] = argv[i];
			//printf("|%s|\n", cmds[l][m]);
			m++;
		}
		i++;
	}
	if (m == 0)
		cmds[l] = 0;
	else
	{
		cmds[l][m] = 0;
		cmds[l + 1] = 0;
	}
}

int main(int argc, char **argv, char **env)
{
	char ***cmds; //First split with | and ; //Second with words for each command

	if (argc == 1)
		return (0);
	if ((cmds = malloc(sizeof(char *) * argc + 1)) == 0) //allocate max memory potentially necessary each time
		ft_fatal_error();
	parsing(argc, argv, cmds);
	launch_cmds(cmds, env);
	exit(0); //No leaks
}

BASH:
#include <sys/wait.h>
void launch_cmd(char ***cmds, int i, char **env, int *fd);
void ft_fatal_error()
          write(2, "error: fatal\n", 13);
          exit(EXIT_FAILURE); //Only EXIT_FAILURE is the standard value for returning unsuccessful termination, but 1 is used for the same in many implementations.
int ft_strlen2(char **a)
	while(a[i])
int ft_strlen(char *a)
	while(a[i])
			ft_fatal_error();
		ft_fatal_error();
		ft_fatal_error();
		ft_fatal_error();
			ft_fatal_error();
			ft_fatal_error();
			ft_fatal_error();
			ft_fatal_error();
			ft_fatal_error();
			ft_fatal_error();
			ft_fatal_error();
		launch_cmd(cmd, i + 2, env, fd);
			ft_fatal_error();
void launch_cmd(char ***cmds, int i, char **env, int *fd)
void launch_cmds(char ***cmds, char **env)
		launch_cmd(cmds, i, env, fd);
	if ((cmds[0] = malloc(sizeof(char *) * argc + 1)) == 0)
		ft_fatal_error();
	while (i < argc)
		else if (m == 0 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
		else if (strcmp(argv[i], ";") == 0)
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		else if (strcmp(argv[i], "|") == 0)
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
			cmds[l][0] = argv[i];
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
			cmds[l][m] = argv[i];
	char ***cmds; //First split with | and ; //Second with words for each command
	if ((cmds = malloc(sizeof(char *) * argc + 1)) == 0) //allocate max memory potentially necessary each time
		ft_fatal_error();
	launch_cmds(cmds, env);
	exit(0); //No leaks
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>

void launch_cmd(char ***cmds, int i, char **env, int *fd);


void ft_fatal_error()
{
          write(2, "error: fatal\n", 13);
          exit(EXIT_FAILURE); //Only EXIT_FAILURE is the standard value for returning unsuccessful termination, but 1 is used for the same in many implementations.
 }

int ft_strlen2(char **a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

int ft_strlen(char *a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

void ft_cd(char **cmd)
{
	if (ft_strlen2(cmd) != 2)
		write(2, "error: cd: bad arguments\n", 25);
	else
	{
		if (chdir(cmd[1]) == -1)
		{
			write(2, "error: cd: cannot change directory to ", 38);
			write(2, cmd[1], ft_strlen(cmd[1]));
			write(2, "\n", 1);
		}
	}
}

void ft_exec(char **cmd, char **env)
{
	pid_t pid;

	if ((pid = fork()) == -1)
			ft_fatal_error();
	if (!pid)
	{
		if (execve(cmd[0], cmd, env) == -1)
		{
			write(2, "error: cannot execute ", 22);
			write(2, cmd[0], ft_strlen(cmd[0]));
			write(2, "\n", 1);
		}
		exit(0);
	}
	if (waitpid(pid, 0, 0) == -1)
		ft_fatal_error();
}

void ft_pipe(char ***cmd, int i, char **env, int *fd)
{
  pid_t pid;

	if (pipe(fd) == -1)
		ft_fatal_error();
	if ((pid = fork()) == -1)
		ft_fatal_error();
	if (!pid)
	{
		if (close(fd[0]) == -1)
			ft_fatal_error();
		if (dup2(fd[1], 1) == -1)
			ft_fatal_error();
		ft_exec(cmd[i], env);
		if (dup2(1, fd[1]) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		exit(0);
	}
	else
	{
		if (waitpid(pid, 0, 0) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		if (dup2(fd[0], 0) == -1)
			ft_fatal_error();
		launch_cmd(cmd, i + 2, env, fd);
		if (dup2(0, fd[0]) == -1)
			ft_fatal_error();
	}
}

void launch_cmd(char ***cmds, int i, char **env, int *fd)
{
	//printf("{%s %s}\n", cmds[i][0], cmds[i][1]);
	if (cmds[i + 1] != 0 && strcmp(cmds[i + 1][0], "|") == 0)
  {
    close(fd[0]);
		ft_pipe(cmds, i,  env, fd);
  }
	else if (strcmp(cmds[i][0], "cd") == 0)
		ft_cd(cmds[i]);
	else
		ft_exec(cmds[i], env);
}

void launch_cmds(char ***cmds, char **env)
{
	int i;
  int fd[2];

	i = 0;
	while (cmds[i])
	{
		if (strcmp(cmds[i][0], "|") == 0)
		{
			while(cmds[i] && strcmp(cmds[i][0], "|") == 0)
				i += 2;
			if (!cmds[i])
				break ;
		}
		launch_cmd(cmds, i, env, fd);
		i++;
	}
}

void parsing(int argc, char **argv, char ***cmds)
{
	int i;
	int l;
	int m;

	i = 1;
	l = 0;
	m = 0;
	if ((cmds[0] = malloc(sizeof(char *) * argc + 1)) == 0)
		ft_fatal_error();
	while (i < argc)
	{
		if (i == argc - 1 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			break ;
		else if (m == 0 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			(void)0;
		else if (strcmp(argv[i], ";") == 0)
		{
			cmds[l][m] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else if (strcmp(argv[i], "|") == 0)
		{
			cmds[l][m] = 0;
			l++;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
			cmds[l][0] = argv[i];
			cmds[l][1] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else
		{
			cmds[l][m] = argv[i];
			//printf("|%s|\n", cmds[l][m]);
			m++;
		}
		i++;
	}
	if (m == 0)
		cmds[l] = 0;
	else
	{
		cmds[l][m] = 0;
		cmds[l + 1] = 0;
	}
}

int main(int argc, char **argv, char **env)
{
	char ***cmds; //First split with | and ; //Second with words for each command

	if (argc == 1)
		return (0);
	if ((cmds = malloc(sizeof(char *) * argc + 1)) == 0) //allocate max memory potentially necessary each time
		ft_fatal_error();
	parsing(argc, argv, cmds);
	launch_cmds(cmds, env);
	exit(0); //No leaks
}

****************************************
command:
/bin/cat microshell.c "|" /usr/bin/grep a "|" /usr/bin/grep w ";" /bin/cat microshell.c ";"

****************************************
==========output==========
YOU:
#include <sys/wait.h>
          write(2, "error: fatal\n", 13);
	while(a[i])
	while(a[i])
		write(2, "error: cd: bad arguments\n", 25);
			write(2, "error: cd: cannot change directory to ", 38);
			write(2, "error: cannot execute ", 22);
	if (waitpid(pid, 0, 0) == -1)
		if (waitpid(pid, 0, 0) == -1)
	while (i < argc)
	char ***cmds; //First split with | and ; //Second with words for each command
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>

void launch_cmd(char ***cmds, int i, char **env, int *fd);


void ft_fatal_error()
{
          write(2, "error: fatal\n", 13);
          exit(EXIT_FAILURE); //Only EXIT_FAILURE is the standard value for returning unsuccessful termination, but 1 is used for the same in many implementations.
 }

int ft_strlen2(char **a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

int ft_strlen(char *a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

void ft_cd(char **cmd)
{
	if (ft_strlen2(cmd) != 2)
		write(2, "error: cd: bad arguments\n", 25);
	else
	{
		if (chdir(cmd[1]) == -1)
		{
			write(2, "error: cd: cannot change directory to ", 38);
			write(2, cmd[1], ft_strlen(cmd[1]));
			write(2, "\n", 1);
		}
	}
}

void ft_exec(char **cmd, char **env)
{
	pid_t pid;

	if ((pid = fork()) == -1)
			ft_fatal_error();
	if (!pid)
	{
		if (execve(cmd[0], cmd, env) == -1)
		{
			write(2, "error: cannot execute ", 22);
			write(2, cmd[0], ft_strlen(cmd[0]));
			write(2, "\n", 1);
		}
		exit(0);
	}
	if (waitpid(pid, 0, 0) == -1)
		ft_fatal_error();
}

void ft_pipe(char ***cmd, int i, char **env, int *fd)
{
  pid_t pid;

	if (pipe(fd) == -1)
		ft_fatal_error();
	if ((pid = fork()) == -1)
		ft_fatal_error();
	if (!pid)
	{
		if (close(fd[0]) == -1)
			ft_fatal_error();
		if (dup2(fd[1], 1) == -1)
			ft_fatal_error();
		ft_exec(cmd[i], env);
		if (dup2(1, fd[1]) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		exit(0);
	}
	else
	{
		if (waitpid(pid, 0, 0) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		if (dup2(fd[0], 0) == -1)
			ft_fatal_error();
		launch_cmd(cmd, i + 2, env, fd);
		if (dup2(0, fd[0]) == -1)
			ft_fatal_error();
	}
}

void launch_cmd(char ***cmds, int i, char **env, int *fd)
{
	//printf("{%s %s}\n", cmds[i][0], cmds[i][1]);
	if (cmds[i + 1] != 0 && strcmp(cmds[i + 1][0], "|") == 0)
  {
    close(fd[0]);
		ft_pipe(cmds, i,  env, fd);
  }
	else if (strcmp(cmds[i][0], "cd") == 0)
		ft_cd(cmds[i]);
	else
		ft_exec(cmds[i], env);
}

void launch_cmds(char ***cmds, char **env)
{
	int i;
  int fd[2];

	i = 0;
	while (cmds[i])
	{
		if (strcmp(cmds[i][0], "|") == 0)
		{
			while(cmds[i] && strcmp(cmds[i][0], "|") == 0)
				i += 2;
			if (!cmds[i])
				break ;
		}
		launch_cmd(cmds, i, env, fd);
		i++;
	}
}

void parsing(int argc, char **argv, char ***cmds)
{
	int i;
	int l;
	int m;

	i = 1;
	l = 0;
	m = 0;
	if ((cmds[0] = malloc(sizeof(char *) * argc + 1)) == 0)
		ft_fatal_error();
	while (i < argc)
	{
		if (i == argc - 1 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			break ;
		else if (m == 0 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			(void)0;
		else if (strcmp(argv[i], ";") == 0)
		{
			cmds[l][m] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else if (strcmp(argv[i], "|") == 0)
		{
			cmds[l][m] = 0;
			l++;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
			cmds[l][0] = argv[i];
			cmds[l][1] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else
		{
			cmds[l][m] = argv[i];
			//printf("|%s|\n", cmds[l][m]);
			m++;
		}
		i++;
	}
	if (m == 0)
		cmds[l] = 0;
	else
	{
		cmds[l][m] = 0;
		cmds[l + 1] = 0;
	}
}

int main(int argc, char **argv, char **env)
{
	char ***cmds; //First split with | and ; //Second with words for each command

	if (argc == 1)
		return (0);
	if ((cmds = malloc(sizeof(char *) * argc + 1)) == 0) //allocate max memory potentially necessary each time
		ft_fatal_error();
	parsing(argc, argv, cmds);
	launch_cmds(cmds, env);
	exit(0); //No leaks
}

BASH:
#include <sys/wait.h>
          write(2, "error: fatal\n", 13);
	while(a[i])
	while(a[i])
		write(2, "error: cd: bad arguments\n", 25);
			write(2, "error: cd: cannot change directory to ", 38);
			write(2, "error: cannot execute ", 22);
	if (waitpid(pid, 0, 0) == -1)
		if (waitpid(pid, 0, 0) == -1)
	while (i < argc)
	char ***cmds; //First split with | and ; //Second with words for each command
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>

void launch_cmd(char ***cmds, int i, char **env, int *fd);


void ft_fatal_error()
{
          write(2, "error: fatal\n", 13);
          exit(EXIT_FAILURE); //Only EXIT_FAILURE is the standard value for returning unsuccessful termination, but 1 is used for the same in many implementations.
 }

int ft_strlen2(char **a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

int ft_strlen(char *a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

void ft_cd(char **cmd)
{
	if (ft_strlen2(cmd) != 2)
		write(2, "error: cd: bad arguments\n", 25);
	else
	{
		if (chdir(cmd[1]) == -1)
		{
			write(2, "error: cd: cannot change directory to ", 38);
			write(2, cmd[1], ft_strlen(cmd[1]));
			write(2, "\n", 1);
		}
	}
}

void ft_exec(char **cmd, char **env)
{
	pid_t pid;

	if ((pid = fork()) == -1)
			ft_fatal_error();
	if (!pid)
	{
		if (execve(cmd[0], cmd, env) == -1)
		{
			write(2, "error: cannot execute ", 22);
			write(2, cmd[0], ft_strlen(cmd[0]));
			write(2, "\n", 1);
		}
		exit(0);
	}
	if (waitpid(pid, 0, 0) == -1)
		ft_fatal_error();
}

void ft_pipe(char ***cmd, int i, char **env, int *fd)
{
  pid_t pid;

	if (pipe(fd) == -1)
		ft_fatal_error();
	if ((pid = fork()) == -1)
		ft_fatal_error();
	if (!pid)
	{
		if (close(fd[0]) == -1)
			ft_fatal_error();
		if (dup2(fd[1], 1) == -1)
			ft_fatal_error();
		ft_exec(cmd[i], env);
		if (dup2(1, fd[1]) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		exit(0);
	}
	else
	{
		if (waitpid(pid, 0, 0) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		if (dup2(fd[0], 0) == -1)
			ft_fatal_error();
		launch_cmd(cmd, i + 2, env, fd);
		if (dup2(0, fd[0]) == -1)
			ft_fatal_error();
	}
}

void launch_cmd(char ***cmds, int i, char **env, int *fd)
{
	//printf("{%s %s}\n", cmds[i][0], cmds[i][1]);
	if (cmds[i + 1] != 0 && strcmp(cmds[i + 1][0], "|") == 0)
  {
    close(fd[0]);
		ft_pipe(cmds, i,  env, fd);
  }
	else if (strcmp(cmds[i][0], "cd") == 0)
		ft_cd(cmds[i]);
	else
		ft_exec(cmds[i], env);
}

void launch_cmds(char ***cmds, char **env)
{
	int i;
  int fd[2];

	i = 0;
	while (cmds[i])
	{
		if (strcmp(cmds[i][0], "|") == 0)
		{
			while(cmds[i] && strcmp(cmds[i][0], "|") == 0)
				i += 2;
			if (!cmds[i])
				break ;
		}
		launch_cmd(cmds, i, env, fd);
		i++;
	}
}

void parsing(int argc, char **argv, char ***cmds)
{
	int i;
	int l;
	int m;

	i = 1;
	l = 0;
	m = 0;
	if ((cmds[0] = malloc(sizeof(char *) * argc + 1)) == 0)
		ft_fatal_error();
	while (i < argc)
	{
		if (i == argc - 1 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			break ;
		else if (m == 0 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			(void)0;
		else if (strcmp(argv[i], ";") == 0)
		{
			cmds[l][m] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else if (strcmp(argv[i], "|") == 0)
		{
			cmds[l][m] = 0;
			l++;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
			cmds[l][0] = argv[i];
			cmds[l][1] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else
		{
			cmds[l][m] = argv[i];
			//printf("|%s|\n", cmds[l][m]);
			m++;
		}
		i++;
	}
	if (m == 0)
		cmds[l] = 0;
	else
	{
		cmds[l][m] = 0;
		cmds[l + 1] = 0;
	}
}

int main(int argc, char **argv, char **env)
{
	char ***cmds; //First split with | and ; //Second with words for each command

	if (argc == 1)
		return (0);
	if ((cmds = malloc(sizeof(char *) * argc + 1)) == 0) //allocate max memory potentially necessary each time
		ft_fatal_error();
	parsing(argc, argv, cmds);
	launch_cmds(cmds, env);
	exit(0); //No leaks
}

****************************************
command:
/bin/cat microshell.c "|" /usr/bin/grep a "|" /usr/bin/grep l ";" /bin/cat microshell.c

****************************************
==========output==========
YOU:
#include <sys/wait.h>
void launch_cmd(char ***cmds, int i, char **env, int *fd);
void ft_fatal_error()
          write(2, "error: fatal\n", 13);
          exit(EXIT_FAILURE); //Only EXIT_FAILURE is the standard value for returning unsuccessful termination, but 1 is used for the same in many implementations.
int ft_strlen2(char **a)
	while(a[i])
int ft_strlen(char *a)
	while(a[i])
			ft_fatal_error();
		ft_fatal_error();
		ft_fatal_error();
		ft_fatal_error();
			ft_fatal_error();
			ft_fatal_error();
			ft_fatal_error();
			ft_fatal_error();
			ft_fatal_error();
			ft_fatal_error();
			ft_fatal_error();
		launch_cmd(cmd, i + 2, env, fd);
			ft_fatal_error();
void launch_cmd(char ***cmds, int i, char **env, int *fd)
void launch_cmds(char ***cmds, char **env)
		launch_cmd(cmds, i, env, fd);
	if ((cmds[0] = malloc(sizeof(char *) * argc + 1)) == 0)
		ft_fatal_error();
	while (i < argc)
		else if (m == 0 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
		else if (strcmp(argv[i], ";") == 0)
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		else if (strcmp(argv[i], "|") == 0)
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
			cmds[l][0] = argv[i];
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
			cmds[l][m] = argv[i];
	char ***cmds; //First split with | and ; //Second with words for each command
	if ((cmds = malloc(sizeof(char *) * argc + 1)) == 0) //allocate max memory potentially necessary each time
		ft_fatal_error();
	launch_cmds(cmds, env);
	exit(0); //No leaks
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>

void launch_cmd(char ***cmds, int i, char **env, int *fd);


void ft_fatal_error()
{
          write(2, "error: fatal\n", 13);
          exit(EXIT_FAILURE); //Only EXIT_FAILURE is the standard value for returning unsuccessful termination, but 1 is used for the same in many implementations.
 }

int ft_strlen2(char **a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

int ft_strlen(char *a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

void ft_cd(char **cmd)
{
	if (ft_strlen2(cmd) != 2)
		write(2, "error: cd: bad arguments\n", 25);
	else
	{
		if (chdir(cmd[1]) == -1)
		{
			write(2, "error: cd: cannot change directory to ", 38);
			write(2, cmd[1], ft_strlen(cmd[1]));
			write(2, "\n", 1);
		}
	}
}

void ft_exec(char **cmd, char **env)
{
	pid_t pid;

	if ((pid = fork()) == -1)
			ft_fatal_error();
	if (!pid)
	{
		if (execve(cmd[0], cmd, env) == -1)
		{
			write(2, "error: cannot execute ", 22);
			write(2, cmd[0], ft_strlen(cmd[0]));
			write(2, "\n", 1);
		}
		exit(0);
	}
	if (waitpid(pid, 0, 0) == -1)
		ft_fatal_error();
}

void ft_pipe(char ***cmd, int i, char **env, int *fd)
{
  pid_t pid;

	if (pipe(fd) == -1)
		ft_fatal_error();
	if ((pid = fork()) == -1)
		ft_fatal_error();
	if (!pid)
	{
		if (close(fd[0]) == -1)
			ft_fatal_error();
		if (dup2(fd[1], 1) == -1)
			ft_fatal_error();
		ft_exec(cmd[i], env);
		if (dup2(1, fd[1]) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		exit(0);
	}
	else
	{
		if (waitpid(pid, 0, 0) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		if (dup2(fd[0], 0) == -1)
			ft_fatal_error();
		launch_cmd(cmd, i + 2, env, fd);
		if (dup2(0, fd[0]) == -1)
			ft_fatal_error();
	}
}

void launch_cmd(char ***cmds, int i, char **env, int *fd)
{
	//printf("{%s %s}\n", cmds[i][0], cmds[i][1]);
	if (cmds[i + 1] != 0 && strcmp(cmds[i + 1][0], "|") == 0)
  {
    close(fd[0]);
		ft_pipe(cmds, i,  env, fd);
  }
	else if (strcmp(cmds[i][0], "cd") == 0)
		ft_cd(cmds[i]);
	else
		ft_exec(cmds[i], env);
}

void launch_cmds(char ***cmds, char **env)
{
	int i;
  int fd[2];

	i = 0;
	while (cmds[i])
	{
		if (strcmp(cmds[i][0], "|") == 0)
		{
			while(cmds[i] && strcmp(cmds[i][0], "|") == 0)
				i += 2;
			if (!cmds[i])
				break ;
		}
		launch_cmd(cmds, i, env, fd);
		i++;
	}
}

void parsing(int argc, char **argv, char ***cmds)
{
	int i;
	int l;
	int m;

	i = 1;
	l = 0;
	m = 0;
	if ((cmds[0] = malloc(sizeof(char *) * argc + 1)) == 0)
		ft_fatal_error();
	while (i < argc)
	{
		if (i == argc - 1 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			break ;
		else if (m == 0 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			(void)0;
		else if (strcmp(argv[i], ";") == 0)
		{
			cmds[l][m] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else if (strcmp(argv[i], "|") == 0)
		{
			cmds[l][m] = 0;
			l++;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
			cmds[l][0] = argv[i];
			cmds[l][1] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else
		{
			cmds[l][m] = argv[i];
			//printf("|%s|\n", cmds[l][m]);
			m++;
		}
		i++;
	}
	if (m == 0)
		cmds[l] = 0;
	else
	{
		cmds[l][m] = 0;
		cmds[l + 1] = 0;
	}
}

int main(int argc, char **argv, char **env)
{
	char ***cmds; //First split with | and ; //Second with words for each command

	if (argc == 1)
		return (0);
	if ((cmds = malloc(sizeof(char *) * argc + 1)) == 0) //allocate max memory potentially necessary each time
		ft_fatal_error();
	parsing(argc, argv, cmds);
	launch_cmds(cmds, env);
	exit(0); //No leaks
}

BASH:
#include <sys/wait.h>
void launch_cmd(char ***cmds, int i, char **env, int *fd);
void ft_fatal_error()
          write(2, "error: fatal\n", 13);
          exit(EXIT_FAILURE); //Only EXIT_FAILURE is the standard value for returning unsuccessful termination, but 1 is used for the same in many implementations.
int ft_strlen2(char **a)
	while(a[i])
int ft_strlen(char *a)
	while(a[i])
			ft_fatal_error();
		ft_fatal_error();
		ft_fatal_error();
		ft_fatal_error();
			ft_fatal_error();
			ft_fatal_error();
			ft_fatal_error();
			ft_fatal_error();
			ft_fatal_error();
			ft_fatal_error();
			ft_fatal_error();
		launch_cmd(cmd, i + 2, env, fd);
			ft_fatal_error();
void launch_cmd(char ***cmds, int i, char **env, int *fd)
void launch_cmds(char ***cmds, char **env)
		launch_cmd(cmds, i, env, fd);
	if ((cmds[0] = malloc(sizeof(char *) * argc + 1)) == 0)
		ft_fatal_error();
	while (i < argc)
		else if (m == 0 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
		else if (strcmp(argv[i], ";") == 0)
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		else if (strcmp(argv[i], "|") == 0)
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
			cmds[l][0] = argv[i];
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
			cmds[l][m] = argv[i];
	char ***cmds; //First split with | and ; //Second with words for each command
	if ((cmds = malloc(sizeof(char *) * argc + 1)) == 0) //allocate max memory potentially necessary each time
		ft_fatal_error();
	launch_cmds(cmds, env);
	exit(0); //No leaks
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>

void launch_cmd(char ***cmds, int i, char **env, int *fd);


void ft_fatal_error()
{
          write(2, "error: fatal\n", 13);
          exit(EXIT_FAILURE); //Only EXIT_FAILURE is the standard value for returning unsuccessful termination, but 1 is used for the same in many implementations.
 }

int ft_strlen2(char **a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

int ft_strlen(char *a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

void ft_cd(char **cmd)
{
	if (ft_strlen2(cmd) != 2)
		write(2, "error: cd: bad arguments\n", 25);
	else
	{
		if (chdir(cmd[1]) == -1)
		{
			write(2, "error: cd: cannot change directory to ", 38);
			write(2, cmd[1], ft_strlen(cmd[1]));
			write(2, "\n", 1);
		}
	}
}

void ft_exec(char **cmd, char **env)
{
	pid_t pid;

	if ((pid = fork()) == -1)
			ft_fatal_error();
	if (!pid)
	{
		if (execve(cmd[0], cmd, env) == -1)
		{
			write(2, "error: cannot execute ", 22);
			write(2, cmd[0], ft_strlen(cmd[0]));
			write(2, "\n", 1);
		}
		exit(0);
	}
	if (waitpid(pid, 0, 0) == -1)
		ft_fatal_error();
}

void ft_pipe(char ***cmd, int i, char **env, int *fd)
{
  pid_t pid;

	if (pipe(fd) == -1)
		ft_fatal_error();
	if ((pid = fork()) == -1)
		ft_fatal_error();
	if (!pid)
	{
		if (close(fd[0]) == -1)
			ft_fatal_error();
		if (dup2(fd[1], 1) == -1)
			ft_fatal_error();
		ft_exec(cmd[i], env);
		if (dup2(1, fd[1]) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		exit(0);
	}
	else
	{
		if (waitpid(pid, 0, 0) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		if (dup2(fd[0], 0) == -1)
			ft_fatal_error();
		launch_cmd(cmd, i + 2, env, fd);
		if (dup2(0, fd[0]) == -1)
			ft_fatal_error();
	}
}

void launch_cmd(char ***cmds, int i, char **env, int *fd)
{
	//printf("{%s %s}\n", cmds[i][0], cmds[i][1]);
	if (cmds[i + 1] != 0 && strcmp(cmds[i + 1][0], "|") == 0)
  {
    close(fd[0]);
		ft_pipe(cmds, i,  env, fd);
  }
	else if (strcmp(cmds[i][0], "cd") == 0)
		ft_cd(cmds[i]);
	else
		ft_exec(cmds[i], env);
}

void launch_cmds(char ***cmds, char **env)
{
	int i;
  int fd[2];

	i = 0;
	while (cmds[i])
	{
		if (strcmp(cmds[i][0], "|") == 0)
		{
			while(cmds[i] && strcmp(cmds[i][0], "|") == 0)
				i += 2;
			if (!cmds[i])
				break ;
		}
		launch_cmd(cmds, i, env, fd);
		i++;
	}
}

void parsing(int argc, char **argv, char ***cmds)
{
	int i;
	int l;
	int m;

	i = 1;
	l = 0;
	m = 0;
	if ((cmds[0] = malloc(sizeof(char *) * argc + 1)) == 0)
		ft_fatal_error();
	while (i < argc)
	{
		if (i == argc - 1 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			break ;
		else if (m == 0 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			(void)0;
		else if (strcmp(argv[i], ";") == 0)
		{
			cmds[l][m] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else if (strcmp(argv[i], "|") == 0)
		{
			cmds[l][m] = 0;
			l++;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
			cmds[l][0] = argv[i];
			cmds[l][1] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else
		{
			cmds[l][m] = argv[i];
			//printf("|%s|\n", cmds[l][m]);
			m++;
		}
		i++;
	}
	if (m == 0)
		cmds[l] = 0;
	else
	{
		cmds[l][m] = 0;
		cmds[l + 1] = 0;
	}
}

int main(int argc, char **argv, char **env)
{
	char ***cmds; //First split with | and ; //Second with words for each command

	if (argc == 1)
		return (0);
	if ((cmds = malloc(sizeof(char *) * argc + 1)) == 0) //allocate max memory potentially necessary each time
		ft_fatal_error();
	parsing(argc, argv, cmds);
	launch_cmds(cmds, env);
	exit(0); //No leaks
}

****************************************
command:
/bin/cat microshell.c ";" /bin/cat microshell.c "|" /usr/bin/grep a "|" /usr/bin/grep b "|" /usr/bin/grep z ";" /bin/cat microshell.c

****************************************
==========output==========
YOU:
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>

void launch_cmd(char ***cmds, int i, char **env, int *fd);


void ft_fatal_error()
{
          write(2, "error: fatal\n", 13);
          exit(EXIT_FAILURE); //Only EXIT_FAILURE is the standard value for returning unsuccessful termination, but 1 is used for the same in many implementations.
 }

int ft_strlen2(char **a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

int ft_strlen(char *a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

void ft_cd(char **cmd)
{
	if (ft_strlen2(cmd) != 2)
		write(2, "error: cd: bad arguments\n", 25);
	else
	{
		if (chdir(cmd[1]) == -1)
		{
			write(2, "error: cd: cannot change directory to ", 38);
			write(2, cmd[1], ft_strlen(cmd[1]));
			write(2, "\n", 1);
		}
	}
}

void ft_exec(char **cmd, char **env)
{
	pid_t pid;

	if ((pid = fork()) == -1)
			ft_fatal_error();
	if (!pid)
	{
		if (execve(cmd[0], cmd, env) == -1)
		{
			write(2, "error: cannot execute ", 22);
			write(2, cmd[0], ft_strlen(cmd[0]));
			write(2, "\n", 1);
		}
		exit(0);
	}
	if (waitpid(pid, 0, 0) == -1)
		ft_fatal_error();
}

void ft_pipe(char ***cmd, int i, char **env, int *fd)
{
  pid_t pid;

	if (pipe(fd) == -1)
		ft_fatal_error();
	if ((pid = fork()) == -1)
		ft_fatal_error();
	if (!pid)
	{
		if (close(fd[0]) == -1)
			ft_fatal_error();
		if (dup2(fd[1], 1) == -1)
			ft_fatal_error();
		ft_exec(cmd[i], env);
		if (dup2(1, fd[1]) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		exit(0);
	}
	else
	{
		if (waitpid(pid, 0, 0) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		if (dup2(fd[0], 0) == -1)
			ft_fatal_error();
		launch_cmd(cmd, i + 2, env, fd);
		if (dup2(0, fd[0]) == -1)
			ft_fatal_error();
	}
}

void launch_cmd(char ***cmds, int i, char **env, int *fd)
{
	//printf("{%s %s}\n", cmds[i][0], cmds[i][1]);
	if (cmds[i + 1] != 0 && strcmp(cmds[i + 1][0], "|") == 0)
  {
    close(fd[0]);
		ft_pipe(cmds, i,  env, fd);
  }
	else if (strcmp(cmds[i][0], "cd") == 0)
		ft_cd(cmds[i]);
	else
		ft_exec(cmds[i], env);
}

void launch_cmds(char ***cmds, char **env)
{
	int i;
  int fd[2];

	i = 0;
	while (cmds[i])
	{
		if (strcmp(cmds[i][0], "|") == 0)
		{
			while(cmds[i] && strcmp(cmds[i][0], "|") == 0)
				i += 2;
			if (!cmds[i])
				break ;
		}
		launch_cmd(cmds, i, env, fd);
		i++;
	}
}

void parsing(int argc, char **argv, char ***cmds)
{
	int i;
	int l;
	int m;

	i = 1;
	l = 0;
	m = 0;
	if ((cmds[0] = malloc(sizeof(char *) * argc + 1)) == 0)
		ft_fatal_error();
	while (i < argc)
	{
		if (i == argc - 1 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			break ;
		else if (m == 0 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			(void)0;
		else if (strcmp(argv[i], ";") == 0)
		{
			cmds[l][m] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else if (strcmp(argv[i], "|") == 0)
		{
			cmds[l][m] = 0;
			l++;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
			cmds[l][0] = argv[i];
			cmds[l][1] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else
		{
			cmds[l][m] = argv[i];
			//printf("|%s|\n", cmds[l][m]);
			m++;
		}
		i++;
	}
	if (m == 0)
		cmds[l] = 0;
	else
	{
		cmds[l][m] = 0;
		cmds[l + 1] = 0;
	}
}

int main(int argc, char **argv, char **env)
{
	char ***cmds; //First split with | and ; //Second with words for each command

	if (argc == 1)
		return (0);
	if ((cmds = malloc(sizeof(char *) * argc + 1)) == 0) //allocate max memory potentially necessary each time
		ft_fatal_error();
	parsing(argc, argv, cmds);
	launch_cmds(cmds, env);
	exit(0); //No leaks
}
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>

void launch_cmd(char ***cmds, int i, char **env, int *fd);


void ft_fatal_error()
{
          write(2, "error: fatal\n", 13);
          exit(EXIT_FAILURE); //Only EXIT_FAILURE is the standard value for returning unsuccessful termination, but 1 is used for the same in many implementations.
 }

int ft_strlen2(char **a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

int ft_strlen(char *a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

void ft_cd(char **cmd)
{
	if (ft_strlen2(cmd) != 2)
		write(2, "error: cd: bad arguments\n", 25);
	else
	{
		if (chdir(cmd[1]) == -1)
		{
			write(2, "error: cd: cannot change directory to ", 38);
			write(2, cmd[1], ft_strlen(cmd[1]));
			write(2, "\n", 1);
		}
	}
}

void ft_exec(char **cmd, char **env)
{
	pid_t pid;

	if ((pid = fork()) == -1)
			ft_fatal_error();
	if (!pid)
	{
		if (execve(cmd[0], cmd, env) == -1)
		{
			write(2, "error: cannot execute ", 22);
			write(2, cmd[0], ft_strlen(cmd[0]));
			write(2, "\n", 1);
		}
		exit(0);
	}
	if (waitpid(pid, 0, 0) == -1)
		ft_fatal_error();
}

void ft_pipe(char ***cmd, int i, char **env, int *fd)
{
  pid_t pid;

	if (pipe(fd) == -1)
		ft_fatal_error();
	if ((pid = fork()) == -1)
		ft_fatal_error();
	if (!pid)
	{
		if (close(fd[0]) == -1)
			ft_fatal_error();
		if (dup2(fd[1], 1) == -1)
			ft_fatal_error();
		ft_exec(cmd[i], env);
		if (dup2(1, fd[1]) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		exit(0);
	}
	else
	{
		if (waitpid(pid, 0, 0) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		if (dup2(fd[0], 0) == -1)
			ft_fatal_error();
		launch_cmd(cmd, i + 2, env, fd);
		if (dup2(0, fd[0]) == -1)
			ft_fatal_error();
	}
}

void launch_cmd(char ***cmds, int i, char **env, int *fd)
{
	//printf("{%s %s}\n", cmds[i][0], cmds[i][1]);
	if (cmds[i + 1] != 0 && strcmp(cmds[i + 1][0], "|") == 0)
  {
    close(fd[0]);
		ft_pipe(cmds, i,  env, fd);
  }
	else if (strcmp(cmds[i][0], "cd") == 0)
		ft_cd(cmds[i]);
	else
		ft_exec(cmds[i], env);
}

void launch_cmds(char ***cmds, char **env)
{
	int i;
  int fd[2];

	i = 0;
	while (cmds[i])
	{
		if (strcmp(cmds[i][0], "|") == 0)
		{
			while(cmds[i] && strcmp(cmds[i][0], "|") == 0)
				i += 2;
			if (!cmds[i])
				break ;
		}
		launch_cmd(cmds, i, env, fd);
		i++;
	}
}

void parsing(int argc, char **argv, char ***cmds)
{
	int i;
	int l;
	int m;

	i = 1;
	l = 0;
	m = 0;
	if ((cmds[0] = malloc(sizeof(char *) * argc + 1)) == 0)
		ft_fatal_error();
	while (i < argc)
	{
		if (i == argc - 1 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			break ;
		else if (m == 0 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			(void)0;
		else if (strcmp(argv[i], ";") == 0)
		{
			cmds[l][m] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else if (strcmp(argv[i], "|") == 0)
		{
			cmds[l][m] = 0;
			l++;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
			cmds[l][0] = argv[i];
			cmds[l][1] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else
		{
			cmds[l][m] = argv[i];
			//printf("|%s|\n", cmds[l][m]);
			m++;
		}
		i++;
	}
	if (m == 0)
		cmds[l] = 0;
	else
	{
		cmds[l][m] = 0;
		cmds[l + 1] = 0;
	}
}

int main(int argc, char **argv, char **env)
{
	char ***cmds; //First split with | and ; //Second with words for each command

	if (argc == 1)
		return (0);
	if ((cmds = malloc(sizeof(char *) * argc + 1)) == 0) //allocate max memory potentially necessary each time
		ft_fatal_error();
	parsing(argc, argv, cmds);
	launch_cmds(cmds, env);
	exit(0); //No leaks
}

BASH:
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>

void launch_cmd(char ***cmds, int i, char **env, int *fd);


void ft_fatal_error()
{
          write(2, "error: fatal\n", 13);
          exit(EXIT_FAILURE); //Only EXIT_FAILURE is the standard value for returning unsuccessful termination, but 1 is used for the same in many implementations.
 }

int ft_strlen2(char **a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

int ft_strlen(char *a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

void ft_cd(char **cmd)
{
	if (ft_strlen2(cmd) != 2)
		write(2, "error: cd: bad arguments\n", 25);
	else
	{
		if (chdir(cmd[1]) == -1)
		{
			write(2, "error: cd: cannot change directory to ", 38);
			write(2, cmd[1], ft_strlen(cmd[1]));
			write(2, "\n", 1);
		}
	}
}

void ft_exec(char **cmd, char **env)
{
	pid_t pid;

	if ((pid = fork()) == -1)
			ft_fatal_error();
	if (!pid)
	{
		if (execve(cmd[0], cmd, env) == -1)
		{
			write(2, "error: cannot execute ", 22);
			write(2, cmd[0], ft_strlen(cmd[0]));
			write(2, "\n", 1);
		}
		exit(0);
	}
	if (waitpid(pid, 0, 0) == -1)
		ft_fatal_error();
}

void ft_pipe(char ***cmd, int i, char **env, int *fd)
{
  pid_t pid;

	if (pipe(fd) == -1)
		ft_fatal_error();
	if ((pid = fork()) == -1)
		ft_fatal_error();
	if (!pid)
	{
		if (close(fd[0]) == -1)
			ft_fatal_error();
		if (dup2(fd[1], 1) == -1)
			ft_fatal_error();
		ft_exec(cmd[i], env);
		if (dup2(1, fd[1]) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		exit(0);
	}
	else
	{
		if (waitpid(pid, 0, 0) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		if (dup2(fd[0], 0) == -1)
			ft_fatal_error();
		launch_cmd(cmd, i + 2, env, fd);
		if (dup2(0, fd[0]) == -1)
			ft_fatal_error();
	}
}

void launch_cmd(char ***cmds, int i, char **env, int *fd)
{
	//printf("{%s %s}\n", cmds[i][0], cmds[i][1]);
	if (cmds[i + 1] != 0 && strcmp(cmds[i + 1][0], "|") == 0)
  {
    close(fd[0]);
		ft_pipe(cmds, i,  env, fd);
  }
	else if (strcmp(cmds[i][0], "cd") == 0)
		ft_cd(cmds[i]);
	else
		ft_exec(cmds[i], env);
}

void launch_cmds(char ***cmds, char **env)
{
	int i;
  int fd[2];

	i = 0;
	while (cmds[i])
	{
		if (strcmp(cmds[i][0], "|") == 0)
		{
			while(cmds[i] && strcmp(cmds[i][0], "|") == 0)
				i += 2;
			if (!cmds[i])
				break ;
		}
		launch_cmd(cmds, i, env, fd);
		i++;
	}
}

void parsing(int argc, char **argv, char ***cmds)
{
	int i;
	int l;
	int m;

	i = 1;
	l = 0;
	m = 0;
	if ((cmds[0] = malloc(sizeof(char *) * argc + 1)) == 0)
		ft_fatal_error();
	while (i < argc)
	{
		if (i == argc - 1 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			break ;
		else if (m == 0 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			(void)0;
		else if (strcmp(argv[i], ";") == 0)
		{
			cmds[l][m] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else if (strcmp(argv[i], "|") == 0)
		{
			cmds[l][m] = 0;
			l++;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
			cmds[l][0] = argv[i];
			cmds[l][1] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else
		{
			cmds[l][m] = argv[i];
			//printf("|%s|\n", cmds[l][m]);
			m++;
		}
		i++;
	}
	if (m == 0)
		cmds[l] = 0;
	else
	{
		cmds[l][m] = 0;
		cmds[l + 1] = 0;
	}
}

int main(int argc, char **argv, char **env)
{
	char ***cmds; //First split with | and ; //Second with words for each command

	if (argc == 1)
		return (0);
	if ((cmds = malloc(sizeof(char *) * argc + 1)) == 0) //allocate max memory potentially necessary each time
		ft_fatal_error();
	parsing(argc, argv, cmds);
	launch_cmds(cmds, env);
	exit(0); //No leaks
}
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>

void launch_cmd(char ***cmds, int i, char **env, int *fd);


void ft_fatal_error()
{
          write(2, "error: fatal\n", 13);
          exit(EXIT_FAILURE); //Only EXIT_FAILURE is the standard value for returning unsuccessful termination, but 1 is used for the same in many implementations.
 }

int ft_strlen2(char **a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

int ft_strlen(char *a)
{
	int i;

	i = 0;
	while(a[i])
		i++;
	return (i);
}

void ft_cd(char **cmd)
{
	if (ft_strlen2(cmd) != 2)
		write(2, "error: cd: bad arguments\n", 25);
	else
	{
		if (chdir(cmd[1]) == -1)
		{
			write(2, "error: cd: cannot change directory to ", 38);
			write(2, cmd[1], ft_strlen(cmd[1]));
			write(2, "\n", 1);
		}
	}
}

void ft_exec(char **cmd, char **env)
{
	pid_t pid;

	if ((pid = fork()) == -1)
			ft_fatal_error();
	if (!pid)
	{
		if (execve(cmd[0], cmd, env) == -1)
		{
			write(2, "error: cannot execute ", 22);
			write(2, cmd[0], ft_strlen(cmd[0]));
			write(2, "\n", 1);
		}
		exit(0);
	}
	if (waitpid(pid, 0, 0) == -1)
		ft_fatal_error();
}

void ft_pipe(char ***cmd, int i, char **env, int *fd)
{
  pid_t pid;

	if (pipe(fd) == -1)
		ft_fatal_error();
	if ((pid = fork()) == -1)
		ft_fatal_error();
	if (!pid)
	{
		if (close(fd[0]) == -1)
			ft_fatal_error();
		if (dup2(fd[1], 1) == -1)
			ft_fatal_error();
		ft_exec(cmd[i], env);
		if (dup2(1, fd[1]) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		exit(0);
	}
	else
	{
		if (waitpid(pid, 0, 0) == -1)
			ft_fatal_error();
		if (close(fd[1]) == -1)
			ft_fatal_error();
		if (dup2(fd[0], 0) == -1)
			ft_fatal_error();
		launch_cmd(cmd, i + 2, env, fd);
		if (dup2(0, fd[0]) == -1)
			ft_fatal_error();
	}
}

void launch_cmd(char ***cmds, int i, char **env, int *fd)
{
	//printf("{%s %s}\n", cmds[i][0], cmds[i][1]);
	if (cmds[i + 1] != 0 && strcmp(cmds[i + 1][0], "|") == 0)
  {
    close(fd[0]);
		ft_pipe(cmds, i,  env, fd);
  }
	else if (strcmp(cmds[i][0], "cd") == 0)
		ft_cd(cmds[i]);
	else
		ft_exec(cmds[i], env);
}

void launch_cmds(char ***cmds, char **env)
{
	int i;
  int fd[2];

	i = 0;
	while (cmds[i])
	{
		if (strcmp(cmds[i][0], "|") == 0)
		{
			while(cmds[i] && strcmp(cmds[i][0], "|") == 0)
				i += 2;
			if (!cmds[i])
				break ;
		}
		launch_cmd(cmds, i, env, fd);
		i++;
	}
}

void parsing(int argc, char **argv, char ***cmds)
{
	int i;
	int l;
	int m;

	i = 1;
	l = 0;
	m = 0;
	if ((cmds[0] = malloc(sizeof(char *) * argc + 1)) == 0)
		ft_fatal_error();
	while (i < argc)
	{
		if (i == argc - 1 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			break ;
		else if (m == 0 && (strcmp(argv[i], "|") == 0 || strcmp(argv[i], ";") == 0))
			(void)0;
		else if (strcmp(argv[i], ";") == 0)
		{
			cmds[l][m] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else if (strcmp(argv[i], "|") == 0)
		{
			cmds[l][m] = 0;
			l++;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
			cmds[l][0] = argv[i];
			cmds[l][1] = 0;
			l++;
			m = 0;
			if ((cmds[l] = malloc(sizeof(char *) * argc + 1)) == 0)
				ft_fatal_error();
		}
		else
		{
			cmds[l][m] = argv[i];
			//printf("|%s|\n", cmds[l][m]);
			m++;
		}
		i++;
	}
	if (m == 0)
		cmds[l] = 0;
	else
	{
		cmds[l][m] = 0;
		cmds[l + 1] = 0;
	}
}

int main(int argc, char **argv, char **env)
{
	char ***cmds; //First split with | and ; //Second with words for each command

	if (argc == 1)
		return (0);
	if ((cmds = malloc(sizeof(char *) * argc + 1)) == 0) //allocate max memory potentially necessary each time
		ft_fatal_error();
	parsing(argc, argv, cmds);
	launch_cmds(cmds, env);
	exit(0); //No leaks
}
